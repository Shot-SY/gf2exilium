<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIRLS FRONTLINE 2: EXILIUM | REDESIGNED</title>
    <!-- 변경: 새로운 폰트 Manrope 추가 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;800&family=Poppins:wght@600&display=swap" rel="stylesheet">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-6Y21MLG0SJ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-6Y21MLG0SJ');
    </script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@2.11.1/tsparticles.bundle.min.js"></script>
    <style>
        :root {
            --bg-color: #0a0c10;
            --primary-accent: #ff4081;
            --secondary-accent: #00f2ff;
            --text-color: #e0e6f0;
            --card-bg: rgba(20, 22, 30, 0.5);
            --card-border: rgba(255, 255, 255, 0.1);
            --card-glow: rgba(0, 242, 255, 0.5);
            --rare-glow: #ff9800;
            --super-rare-glow: #D32F2F;
            --gold-glow: #FFD700;
        }

        /* === 기본 레이아웃 및 배경 === */
        body {
            font-family: 'Manrope', 'Roboto', sans-serif;
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(255,255,255,0.05) 1px, transparent 0),
                radial-gradient(circle at 25px 25px, rgba(255,255,255,0.03) 1px, transparent 0);
            background-size: 50px 50px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px 20px;
            color: var(--text-color);
            position: relative;
            overflow-y: scroll;
        }

        #tsparticles {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-family: 'Poppins', sans-serif;
            font-size: 2.8em;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 0 10px var(--primary-accent), 0 0 20px var(--primary-accent), 0 0 40px var(--primary-accent);
            letter-spacing: 2px;
        }

        /* === 새로운 방식: 캐릭터 플립 카드 디자인 === */
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
            perspective: 1200px; /* 3D 효과를 위한 원근감 설정 */
        }
        
        .character-card { /* 기존 character-box를 대체하는 카드 컨테이너 */
            background-color: transparent;
            width: 100%;
            height: 180px;
            cursor: pointer;
            position: relative;
        }
        
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.7s cubic-bezier(0.25, 1, 0.5, 1);
            transform-style: preserve-3d;
        }

        /* 카드가 선택되면 .card-inner를 180도 회전 */
        .character-card.selected .card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 15px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: box-shadow 0.3s, border-color 0.3s;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 0 0px var(--card-glow);
        }

        .card-back {
            transform: rotateY(180deg);
            justify-content: center;
            gap: 10px;
        }

        @media (hover: hover) and (pointer: fine) {
            .character-card:hover .card-front {
                border-color: var(--secondary-accent);
                box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 0 15px var(--card-glow);
                transform: translateY(-5px);
            }
        }
        
        /* 등급별 테두리 글로우 효과 */
        .character-card.rare .card-front { --card-glow: var(--rare-glow); }
        .character-card.super-rare .card-front { --card-glow: var(--super-rare-glow); }
        .character-card.gold-border .card-front { --card-glow: var(--gold-glow); }

        .character-img {
            width: 80px;
            height: 90px;
            object-fit: cover;
            margin-bottom: 10px;
            border-radius: 10px;
            transition: transform 0.4s;
            filter: grayscale(30%) brightness(0.9);
        }
        .character-card.selected .character-img {
            filter: grayscale(0%) brightness(1);
        }
        .character-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-color);
            text-shadow: 0 0 3px rgba(0,0,0,0.7);
        }
        
        /* 카드 뒷면 (입력창) 스타일 */
        .spinbox-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--secondary-accent);
        }
        .spinbox-container input[type="number"] {
            width: 70px;
            padding: 8px;
            border: 1px solid var(--secondary-accent);
            border-radius: 8px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            background-color: rgba(0,0,0,0.3);
            color: #fff;
            -moz-appearance: textfield; /* Firefox에서 화살표 숨기기 */
        }
        .spinbox-container input::-webkit-outer-spin-button,
        .spinbox-container input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* === 필터 버튼 및 안내문구 === */
        #filterButton {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 40px 0;
            font-size: 18px;
            cursor: pointer;
            background: linear-gradient(45deg, var(--primary-accent), #c2185b);
            color: #fff;
            border: none;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(255, 64, 129, 0.6);
            transition: all 0.3s ease;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            letter-spacing: 1px;
        }
        #filterButton:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 25px rgba(255, 64, 129, 0.8);
        }

        #copyInstruction {
            margin-bottom: 20px;
            color: var(--text-color);
            text-align: center;
            font-size: 1.1em;
            line-height: 1.6;
        }
        #copyInstruction strong { color: var(--secondary-accent); }

        /* === 결과 목록 스타일 === */
        #results {
            padding: 10px;
            height: 800px;
            max-height: 800px;
            overflow-y: auto;
            background: rgba(10, 12, 16, 0.7);
            border-radius: 15px;
            border: 1px solid var(--card-border);
            box-shadow: inset 0 0 25px rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .result-item {
            margin: 15px;
            padding: 20px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .result-item:hover {
            transform: translateY(-5px);
            border-color: var(--primary-accent);
            box-shadow: 0 8px 25px rgba(0,0,0,0.5), 0 0 15px var(--primary-accent);
        }

        .item-images { display: flex; align-items: center; flex-wrap: wrap; gap: 8px; }
        
        .small-character-img {
            width: 48px; height: 48px; object-fit: cover;
            border-radius: 50%; /* 원형 이미지로 변경 */
            border: 2px solid rgba(255,255,255,0.2);
            transition: transform 0.3s;
        }
        .result-item:hover .small-character-img { transform: scale(1.1); }

        .small-character-img.rare { border-color: var(--rare-glow); box-shadow: 0 0 8px var(--rare-glow); }
        .small-character-img.super-rare { border-color: var(--super-rare-glow); box-shadow: 0 0 8px var(--super-rare-glow); }

        .item-box, .price-box {
            height: 48px;
            padding: 0 15px;
            border-radius: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }
        
        .item-box { /* PTicket, Guaranteed */
            background: linear-gradient(45deg, #4a3800, #332600);
            border: 1px solid var(--gold-glow);
            color: #FFD700;
            gap: 5px;
        }
        .item-box .item-title { font-size: 12px; opacity: 0.8; }
        .item-box .item-count { font-size: 14px; }

        .price-box {
            background: linear-gradient(45deg, #104020, #052912);
            border: 1px solid #27ae60;
            color: #90ee90;
            font-size: 16px;
            font-family: 'Poppins', sans-serif;
            margin-left: auto; /* 가격을 오른쪽 끝으로 정렬 */
        }
        
        /* === 로더 및 팝업 스타일 === (기존과 유사하게 유지) */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-color);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000; transition: opacity 0.5s ease;
        }
        #loader.hidden { opacity: 0; visibility: hidden; }
        .spinner {
            border: 8px solid rgba(255,255,255,0.2);
            border-top: 8px solid var(--primary-accent);
            border-radius: 50%; width: 60px; height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        #copyMessage {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #232526, #414345);
            color: #fff; padding: 20px 30px; border-radius: 12px;
            display: none; opacity: 0;
            font-family: 'Poppins', sans-serif; font-size: 1.1em;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5); z-index: 1000;
            transition: opacity 0.3s, transform 0.3s;
            border-left: 4px solid var(--primary-accent);
        }
        #copyMessage.show { display: flex; animation: messagePop 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards; }
        @keyframes messagePop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        .copy-icon { width: 24px; height: 24px; margin-right: 15px; }

        /* 스킨 정보 팝업 관련 */
        .skin-tooltip-icon {
            display: inline-block; background-color: var(--secondary-accent); color: var(--bg-color);
            border-radius: 50%; width: 18px; height: 18px; text-align: center;
            line-height: 18px; font-size: 12px; font-weight: bold; margin-left: 5px;
            user-select: none; vertical-align: middle;
        }
        #skinInfoPopup {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(10, 12, 16, 0.95);
            border: 2px solid var(--primary-accent); border-radius: 10px;
            padding: 20px; box-shadow: 0 8px 30px rgba(0,0,0,0.6); z-index: 3000;
            width: calc(100vw - 40px); max-width: 800px; max-height: 90vh;
            box-sizing: border-box; overflow: auto;
            backdrop-filter: blur(5px);
        }
        #skinInfoPopupImage { display: block; width: 100%; height: auto; border-radius: 5px; }

        /* === 반응형 디자인 === */
        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .character-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; }
            .character-card { height: 150px; }
            .character-img { width: 60px; height: 70px; }
            .character-name { font-size: 14px; }
            #filterButton { padding: 12px; font-size: 16px; }
            .result-item { padding: 15px; margin: 10px; }
            .small-character-img { width: 40px; height: 40px; }
            .item-box, .price-box { height: 40px; padding: 0 12px; font-size: 12px; }
            .price-box { font-size: 14px; }
            .item-box .item-title { display: none; } /* 모바일에서는 공간을 위해 타이틀 숨김 */
        }
        
        /* 기존 CSS에서 불필요하거나 중복되는 부분은 제거/수정 */
        .character-box, .spinbox-container { /* 기존 클래스는 새로운 구조에 맞게 제거/변경 */ }

    </style>
</head>
<body>
    <div id="loader"><div class="spinner"></div></div>
    <div id="tsparticles"></div>
    <h1>GIRLS FRONTLINE 2: EXILIUM</h1>
    <div class="character-grid" id="characterGrid"></div>
    <button id="filterButton">Apply Filter & Search</button>
	<div id="copyInstruction">
      Select characters by clicking on the cards, then flip them over to set the quantity.<br>
	  All accounts have the
	  <strong style="color: skyblue;">
	    <span id="skinInfoTrigger" style="cursor: pointer; text-decoration: underline;" title="스킨 정보 보기">
	      Klukai & colphne skin <span class="skin-tooltip-icon">?</span>
	    </span>
	  </strong>. Click on a result to copy its key.
	</div>
    <div id="results"></div>
    <div id="copyMessage">
        <div class="copy-icon">
             <svg viewBox="0 0 24 24" fill="currentColor" style="fill: var(--primary-accent);">
                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
            </svg>
        </div>
        <span>Copied to Clipboard!</span>
    </div>

    <script>
        // ... 기존 스크립트 시작 ...
        let lastActivityTime = Date.now();
        // (기존 스크립트의 이 부분은 변경 없음)
        
        // --- createCharacterBoxes 함수만 새로운 HTML 구조에 맞게 수정 ---
        function createCharacterBoxes() {
            const characterGrid = document.getElementById('characterGrid');
            characterGrid.innerHTML = '';
            const fragment = document.createDocumentFragment();

            const createCard = (eng, kor, isRare, isSuperRare, isGold) => {
                const charCard = document.createElement('div');
                charCard.className = 'character-card';
                if (isRare) charCard.classList.add('rare');
                if (isSuperRare) charCard.classList.add('super-rare');
                if (isGold) charCard.classList.add('gold-border');
                charCard.dataset.engName = eng;

                const cardInner = document.createElement('div');
                cardInner.className = 'card-inner';

                // --- 카드 앞면 ---
                const cardFront = document.createElement('div');
                cardFront.className = 'card-front';
                
                const img = document.createElement('img');
                img.src = `Portrait/${kor}.png`;
                img.alt = kor;
                img.className = 'character-img';
                img.loading = 'lazy';
                img.decoding = 'async';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'character-name';
                nameSpan.textContent = eng;

                cardFront.append(img, nameSpan);

                // --- 카드 뒷면 ---
                const cardBack = document.createElement('div');
                cardBack.className = 'card-back';

                const spinboxLabel = document.createElement('div');
                spinboxLabel.className = 'spinbox-label';
                spinboxLabel.textContent = 'QUANTITY';

                const spinboxContainer = document.createElement('div');
                spinboxContainer.className = 'spinbox-container';

                const spinbox = document.createElement('input');
                spinbox.type = 'number';
                spinbox.id = `${eng}-spin`;
                spinbox.min = 0;
                spinbox.value = 0;
                spinbox.disabled = true;
                if (eng !== 'PickupTicket') {
                    spinbox.max = 8;
                }

                spinboxContainer.appendChild(spinbox);
                cardBack.append(spinboxLabel, spinboxContainer);

                // --- 조립 ---
                cardInner.append(cardFront, cardBack);
                charCard.appendChild(cardInner);
                fragment.appendChild(charCard);

                charCard.addEventListener('click', (e) => {
                    // input 클릭 시에는 카드 뒤집기 방지
                    if(e.target.tagName.toLowerCase() !== 'input') {
                        toggleSelection(charCard);
                    }
                });
                
                // spinbox 클릭 시 이벤트 전파 중지 (카드가 뒤집히는 것을 방지)
                spinbox.addEventListener('click', (e) => e.stopPropagation());
            };

            characters.forEach(([eng, kor]) => {
                const isGenerallyRare = rareCharacters.some(([rareEng]) => rareEng === eng);
                let isRare = false;
                let isSuperRare = false;
                if (isGenerallyRare) {
                    if (eng.startsWith('gy') || eng.startsWith('to')) {
                        isRare = true;
                    } else {
                        isSuperRare = true;
                    }
                }
                createCard(eng, kor, isRare, isSuperRare, false);
            });
            
            // 픽업 티켓 카드 생성
            createCard('PickupTicket', '픽업티켓', false, false, true);

            characterGrid.appendChild(fragment);
        }

        // toggleSelection 함수도 새로운 구조에 맞게 살짝 수정
        function toggleSelection(charCard) {
            const spinbox = charCard.querySelector('input[type="number"]');
            charCard.classList.toggle('selected');
            
            if (charCard.classList.contains('selected')) {
                spinbox.disabled = false;
                // 선택 시 기본값을 1로 설정 (0일 경우에만)
                if (spinbox.value === '0') {
                    spinbox.value = '1';
                }
            } else {
                spinbox.disabled = true;
                // 선택 해제 시 값을 0으로 리셋
                spinbox.value = 0;
            }
        }
        
        // --- displayResults 함수 수정 (UI 개선) ---
		function displayResults(data) {
		    const res = document.getElementById('results');
		    res.scrollTop = 0;
		    res.innerHTML = ''; // Clear previous results
		
		    const fragment = document.createDocumentFragment();
		
		    const sortedKeys = Object.keys(data).sort((a, b) => {
		        return itemDetailsMap[b].price - itemDetailsMap[a].price;
		    });
		
		    if (sortedKeys.length === 0) {
		        const noResult = document.createElement('div');
		        noResult.textContent = "No matching items found.";
		        noResult.style.textAlign = 'center';
		        noResult.style.padding = '50px';
		        noResult.style.fontSize = '1.2em';
		        noResult.style.color = 'var(--primary-accent)';
		        fragment.appendChild(noResult);
		    } else {
		        sortedKeys.forEach(k => {
		            const item = document.createElement('div');
		            item.className = 'result-item';
		            item.dataset.itemKey = k;
		
		            const itemDetails = itemDetailsMap[k];
		            const charValue = data[k];
		
		            const imgsContainer = document.createElement('div');
		            imgsContainer.className = 'item-images';
		
		            // Characters
		            const charPattern = /([a-z]{2})(\d)/g;
		            let match;
		            while ((match = charPattern.exec(charValue)) !== null) {
		                const code = match[1];
		                const count = parseInt(match[2]);
		                const charInfo = characters.find(([eng]) => eng.startsWith(code));
		                if (charInfo) {
		                    const [engName, korName] = charInfo;
		                    const isGenerallyRare = rareCharacters.some(([rareEng]) => rareEng.startsWith(code));
		                    for (let i = 0; i < count; i++) {
		                        const img = document.createElement('img');
		                        img.src = `Portrait/${korName}.png`;
		                        img.alt = korName;
		                        img.className = 'small-character-img';
		                        img.loading = 'lazy';
		                        img.decoding = 'async';
		                        if (isGenerallyRare) {
		                            if (engName.startsWith('gy') || engName.startsWith('to')) img.classList.add('rare');
		                            else img.classList.add('super-rare');
		                        }
		                        imgsContainer.appendChild(img);
		                    }
		                }
		            }
		
		            // Papasha
		            const papashaImg = document.createElement('img');
		            papashaImg.src = 'Portrait/파파샤.png';
		            papashaImg.alt = '파파샤';
		            papashaImg.className = 'small-character-img';
		            papashaImg.loading = 'lazy';
		            papashaImg.decoding = 'async';
		            imgsContainer.appendChild(papashaImg);
		
		            // Other items
		            if (itemDetails.gemsCount > 0) {
		                const gemsBox = document.createElement('div');
		                gemsBox.className = 'item-box';
		                gemsBox.innerHTML = `<span class="item-title">PTicket</span><span class="item-count">${itemDetails.gemsCount}</span>`;
		                imgsContainer.appendChild(gemsBox);
		            }
		            if (itemDetails.guaranteed) {
		                const guaranteedBox = document.createElement('div');
		                guaranteedBox.className = 'item-box';
		                guaranteedBox.innerHTML = `<span class="item-title">Pickup</span><span class="item-count">✔</span>`;
		                imgsContainer.appendChild(guaranteedBox);
		            }
		
		            // Price
		            const priceBox = document.createElement('div');
		            priceBox.className = 'price-box';
		            priceBox.textContent = `$${itemDetails.price.toFixed(2)}`;
		            imgsContainer.appendChild(priceBox);
		
		            item.appendChild(imgsContainer);
		            item.addEventListener('click', () => copyToClipboard(item));
		            fragment.appendChild(item);
		        });
		    }
		
		    res.appendChild(fragment);
		    document.getElementById('copyInstruction').style.display = 'block';
		}

        // 이후의 모든 JavaScript 코드는 그대로 유지합니다.
        // ... load, filter, copy 등 모든 로직은 변경 없이 완벽하게 동작합니다 ...

        // (여기에 기존 스크립트의 나머지 부분을 그대로 붙여넣으세요)
        // loadData, filterData, getSelectedCharacterSum, checkConditions, copyToClipboard 등 모든 함수
        window.addEventListener('load', () => {
            const lastLoad = localStorage.getItem('lastLoadTime');
            const currentTime = Date.now();
            if (!lastLoad || (currentTime - parseInt(lastLoad)) > 1000) {
                localStorage.setItem('lastLoadTime', currentTime);
                window.location.reload(true);
                return;
            }
            const loader = document.getElementById('loader');
            loadCharacters()
                .then(() => loadData())
                .then(() => filterData())
                .then(() => new Promise(r => setTimeout(r, 500)))
                .then(() => {
                    loader.classList.add('hidden');
                    setTimeout(() => {
                        loader.style.display = 'none';
                        optimizeImages();
                    }, 500);
                })
                .catch(error => {
                    console.error('초기 필터 적용 에러:', error);
                    loader.classList.add('hidden');
                    setTimeout(() => loader.style.display = 'none', 500);
                });
        });
        tsParticles.load("tsparticles", {
            particles: {
                number: { value: 30, density: { enable: true, value_area: 800 }},
                shape: { type: "circle" },
                size: { value: {min: 1, max: 2} },
                move: { enable: true, speed: 0.5, direction: "none", random: true, straight: false, out_mode: "out" },
                color: { value: [var(--primary-accent), var(--secondary-accent)] },
                opacity: { value: {min: 0.1, max: 0.5} },
                links: { enable: true, distance: 150, color: "rgba(255,255,255,0.1)", opacity: 0.2, width: 1 }
            },
            interactivity: { events: { onhover: { enable: true, mode: "grab" }, onclick: { enable: false } }, modes: { grab: { distance: 140, links: { opacity: 0.5 } } } },
            retina_detect: true
        });
        let characters = [];
        let rareCharacters = [];
        function loadCharacters() {
            const ts = new Date().getTime();
            return fetch(`Characters.txt?t=${ts}`)
                .then(r => r.text())
                .then(text => {
                    characters = []; rareCharacters = [];
                    let foundSabrina = false;
                    text.split('\n').forEach(line => {
                        const parts = line.trim().split(' ');
                        if (parts.length >= 2) {
                            const eng = parts[0]; const kor = parts.slice(1).join(' ');
                            if (eng === 'sabrina' && kor === '사브리나') foundSabrina = true;
                            if (eng && kor) {
                                characters.push([eng, kor]);
                                if (!foundSabrina) rareCharacters.push([eng, kor]);
                            }
                        }
                    });
                    createCharacterBoxes();
                })
                .catch(error => { console.error('캐릭터 데이터 로딩 오류:', error); });
        }
        let luaData = {};
        const characterGrid = document.getElementById('characterGrid');
        function filterValidCharacters(charString) {
            const validCharCodes = new Set(characters.map(([eng]) => eng.slice(0, 2)));
            const charGroups = charString.match(/.{1,3}/g) || [];
            const validGroups = charGroups.filter(group => {
                const code = group.slice(0, 2);
                return validCharCodes.has(code);
            });
            return validGroups.join('');
        }
        let itemDetailsMap = {};
        function loadData() {
            const ts = new Date().getTime();
            return fetch(`sorted_data_eng.txt?t=${ts}`)
                .then(r => r.text())
                .then(text => {
                    luaData = {}; itemDetailsMap = {};
                    const lines = text.split('\n');
                    let currentSection = null;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (line.startsWith('===') && line.endsWith('===')) {
                            currentSection = line.slice(4, -4).trim(); continue;
                        }
                        if (line && !line.startsWith('===') && currentSection !== null) {
                            const parts = line.split(' ');
                            if (parts.length < 2) continue;
                            const key = parts[0]; let charString = ''; let j = 1;
                            let itemDetails = { originalText: line, price: 0, guaranteed: line.includes('GUARANTEED'), displayText: '', gemsCount: 0 };
                            const priceMatch = line.match(/\$(\d+\.\d+)/);
                            if (priceMatch) itemDetails.price = parseFloat(priceMatch[1]);
                            while (j < parts.length && !/^\d/.test(parts[j])) {
                                const match = parts[j].match(/^([a-z]+)(\d+)$/i);
                                if (match) { const charName = match[1].toLowerCase(); const count = match[2]; charString += charName.slice(0, 2) + count; }
                                j++;
                            }
                            const gemsMatch = line.match(/(\d+)PickupTicket/i);
                            if (gemsMatch) { itemDetails.gemsCount = parseInt(gemsMatch[1]); itemDetails.gemsText = gemsMatch[0]; }
                            itemDetails.displayText = line.replace(key, '').replace('=', '').trim();
                            luaData[key] = charString; itemDetailsMap[key] = itemDetails;
                        }
                    }
                }).catch(error => { console.error('데이터 로딩 오류:', error); });
        }
		function generateRareSignature(charString) {
			const chars = charString.match(/.{1,3}/g) || []; let signature = {}; const excludedRareCodes = ['gy', 'to'];
			chars.forEach(char => {
				const code = char.slice(0, 2); const count = parseInt(char[2]);
				const isGenerallyRare = rareCharacters.some(([eng]) => eng.slice(0, 2) === code);
				const isExcluded = excludedRareCodes.includes(code);
				if (isGenerallyRare && !isExcluded) signature[code] = (signature[code] || 0) + count;
			});
			return Object.entries(signature).sort((a, b) => a[0].localeCompare(b[0])).map(([code, count]) => `${code}${count}`).join('');
		}
        function filterData() {
            setTimeout(() => {
                let filtered = {};
                for(const [k, v] of Object.entries(luaData)) {
                    const chars = v.match(/.{1,3}/g)||[];
                    if(checkConditions(chars, k)) filtered[k] = v;
                }
                const sortedKeys = Object.keys(filtered).sort((a, b) => itemDetailsMap[b].price - itemDetailsMap[a].price);
                const final = {};
                sortedKeys.forEach(key => { final[key] = filtered[key]; });
                for (const key in final) itemDetailsMap[key].rareSignature = generateRareSignature(final[key]);
                displayResults(final);
            }, 200);
        }
        function getSelectedCharacterSum(luaString) {
            const chars = luaString.match(/.{1,3}/g) || []; let sum = 0;
            chars.forEach(char => {
                const name = char.slice(0, 2); const num = parseInt(char[2]);
                const box = [...document.querySelectorAll('.character-card')].find(b => b.dataset.engName.startsWith(name));
                if (box && box.classList.contains('selected')) sum += num;
            });
            return sum;
        }
        function checkConditions(chars, itemKey) {
            const count = {};
            chars.forEach(c => { const name = c.slice(0,2); const num = parseInt(c[2]); count[name] = (count[name]||0)+num; });
            const characterCondition = characters.every(([eng, kor]) => {
                const box = [...document.querySelectorAll('.character-card')].find(b => b.dataset.engName === eng);
                if(box && box.classList.contains('selected')) return (count[eng.slice(0,2)] || 0) >= parseInt(box.querySelector('input').value);
                return true;
            });
            if (!characterCondition) return false;
            const pickupTicketBox = document.querySelector('.character-card[data-eng-name="PickupTicket"]');
            if (pickupTicketBox && pickupTicketBox.classList.contains('selected')) {
                const requiredTickets = parseInt(pickupTicketBox.querySelector('input').value);
                const itemDetails = itemDetailsMap[itemKey];
                const hasTickets = itemDetails?.gemsCount || 0;
                if (hasTickets < requiredTickets) return false;
            }
            return true;
        }
        function optimizeImages() {
            const images = document.querySelectorAll('img');
            images.forEach(img => {
                if (!img.hasAttribute('loading')) img.loading = 'lazy';
                if (!img.hasAttribute('decoding')) img.decoding = 'async';
            });
        }
        function copyToClipboard(el) {
            const itemKey = el.dataset.itemKey;
            const itemDetails = itemDetailsMap[itemKey];
            if (!itemDetails) return;
            navigator.clipboard.writeText(itemDetails.originalText).then(() => showCopyMessage(), err => console.error('Copy failed: ', err));
        }
        function showCopyMessage(){
            const msg = document.getElementById('copyMessage');
            msg.classList.add('show');
            setTimeout(() => { msg.classList.remove('show'); }, 2000);
        }
		function getSelectedCharacters(){
		    return [...document.querySelectorAll('.character-card')].filter(b => b.classList.contains('selected'))
		        .map(b => {
		            const engName = b.dataset.engName;
		            const shortName = engName === 'PickupTicket' ? 'PT' : engName.slice(0, 2);
		            return `${shortName}:${b.querySelector('input').value}`;
		        }).join(',');
		}
        function throttle(func, delay) {
            let lastCall = 0;
            return function(...args) { const now = Date.now(); if (now - lastCall >= delay) { lastCall = now; return func.apply(this, args); } };
        }
        const throttledFilterHandler = throttle(function() {
            document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
            loadData().then(() => {
                filterData();
                gtag('event', 'apply_filter', { 'selected_characters': getSelectedCharacters() });
            }).catch(error => { console.error('필터 적용 에러:', error); });
        }, 300);
        document.getElementById('filterButton').addEventListener('click', throttledFilterHandler);
		document.addEventListener('DOMContentLoaded', () => {
		    const skinTriggerElement = document.getElementById('skinInfoTrigger');
		    const skinPopupElement = document.getElementById('skinInfoPopup');
		    if (skinTriggerElement && skinPopupElement) {
		        const showPopup = () => { skinPopupElement.style.display = 'block'; };
		        const hidePopup = () => { skinPopupElement.style.display = 'none'; };
		        skinTriggerElement.addEventListener('click', (event) => {
		            event.stopPropagation();
		            if (skinPopupElement.style.display === 'block') hidePopup(); else showPopup();
		        });
		        document.addEventListener('click', (event) => {
		            if (skinPopupElement.style.display === 'block' && !skinPopupElement.contains(event.target) && event.target !== skinTriggerElement && !skinTriggerElement.contains(event.target)) {
		                hidePopup();
		            }
		        });
		    }
		});
    </script>
	<div id="skinInfoPopup">
	  <img id="skinInfoPopupImage" src="Portrait/스킨2종.png" alt="스킨 2종 이미지">
	</div>
</body>
</html>
